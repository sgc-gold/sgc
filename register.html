<head>
<meta charset="UTF-8">
<title>宝石補正データ登録（補正係数自動計算対応）</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
  /* 全体 */
  body {
    font-family: 'Helvetica', Arial, sans-serif;
    background: linear-gradient(to right, #f0f4f8, #d9e2ec);
    padding: 20px;
    margin: 0;
  }

  h2 {
    text-align: center;
    color: #1f2937;
    margin-bottom: 20px;
  }

  .card {
    background: #ffffff;
    border-radius: 12px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.12);
    padding: 20px;
    margin: 10px auto;
    max-width: 600px;
  }

  label {
    display: block;
    margin-top: 12px;
    font-weight: bold;
    color: #334155;
  }

  select, input {
    font-size: 1.1rem;
    padding: 8px 12px;
    border-radius: 8px;
    border: 1px solid #cbd5e1;
    background: #f8fafc;
    margin-top: 6px;
    width: 100%;
    box-sizing: border-box;
  }

  #dimensions .row {
    margin-bottom: 10px;
  }

  /* ----------------- ボタン配置 ----------------- */
  .button-row {
    display: flex;
    justify-content: center;
    gap: 12px;
    margin-top: 16px;
  }

  /* ----------------- ボタンスタイル ----------------- */
  #saveTokenBtn, #addBtn {
    background: linear-gradient(135deg,#bfa14a,#d6c36b);
    color: #fff;
    width: 140px;
    border: none;
    box-shadow: 0 2px 6px rgba(191,161,74,0.35);
    padding: 10px 0;
    border-radius: 8px;
    cursor: pointer;
    font-weight: bold;
    transition: 0.3s;
    font-size: 1.2rem;
    margin: 1rem 0rem;
  }
  #saveTokenBtn:hover, #addBtn:hover {
    opacity: 0.95;
    transform: translateY(-1px);
    box-shadow: 0 4px 10px rgba(191,161,74,0.4);
  }

  #clearBtn {
    background: linear-gradient(135deg,#f2f2f2,#e0e0e0);
    color: #333;
    width: 140px;
    border: 1px solid #ccc;
    padding: 10px 0;
    border-radius: 8px;
    cursor: pointer;
    font-weight: bold;
    transition: 0.3s;
  }
  #clearBtn:hover {
    background: linear-gradient(135deg,#fafafa,#e8e8e8);
  }

  table {
    border-collapse: collapse;
    margin-top: 20px;
    width: 100%;
    font-size: 0.9rem;
  }

  th, td {
    border: 1px solid #ccc;
    padding: 6px;
    text-align: center;
  }

  th {
    background: #f0f0f0;
  }

  @media (max-width: 480px) {
    body { padding: 10px; }
    h2 { font-size: 1.4rem; }
    select, input { font-size: 1rem; padding: 6px 10px; }
    .button-row { flex-direction: column; gap: 8px; }
    #saveTokenBtn, #addBtn, #clearBtn { width: 100%; }
  }
</style>
</head>
<body>

<h2>宝石補正データ 登録・管理</h2>

<div id="authDiv">
  <label>GitHub トークン入力</label>
  <input type="password" id="ghToken" placeholder="Personal Access Token">
  <button id="saveTokenBtn">保存</button>
</div>

<div id="formDiv" style="display:none;">
  <div class="row">
    <label>石の種類</label>
    <select id="stone"></select>
  </div>

  <div class="row">
    <label>カット</label>
    <select id="cut"></select>
  </div>

  <div id="dimensions"></div>

  <div class="row">
    <label>実測重量(g)</label>
    <input id="measured_g" type="number" step="0.001">
  </div>

  <button id="addBtn">登録</button>
</div>

<h3>登録済み補正データ一覧</h3>
<table id="calibTable">
  <thead>
    <tr>
      <th>石</th>
      <th>カット</th>
      <th>寸法</th>
      <th>計算重量(g)</th>
      <th>実測重量(g)</th>
      <th>補正係数</th>
      <th>登録日</th>
    </tr>
  </thead>
  <tbody></tbody>
</table>

<script>
const owner = "sgc-gold";
const repo = "sgc";
const path = "sgc/data/calibrations.json";

let gemstones=[], cuts=[], models={}, calibrations=[];
let ghToken = localStorage.getItem("ghToken") || "";

// ----------------- 認証 -----------------
const authDiv = document.getElementById("authDiv");
const formDiv = document.getElementById("formDiv");

function showForm() {
  authDiv.style.display = "none";
  formDiv.style.display = "block";
  initData();
}

if(ghToken){
  showForm();
}

document.getElementById("saveTokenBtn").addEventListener("click", ()=>{
  const t = document.getElementById("ghToken").value.trim();
  if(!t){ alert("トークンを入力してください"); return; }
  ghToken = t;
  localStorage.setItem("ghToken", ghToken);
  showForm();
});

// ----------------- データ初期化 -----------------
async function initData(){
  try {
    await loadGemstones();
    await loadCuts();
    await loadModels();
    await loadCalibrations();
    displayCalibrations();
  } catch(e) {
    console.error("initData error:", e);
    alert("データ初期化に失敗しました。コンソールを確認してください。");
  }
}

// ----------------- gemstone / cuts / models -----------------
async function loadGemstones(){
  const res = await fetch('./data/gemstones.json').then(r=>r.json());
  gemstones = res.gemstones;

  // カタカナ優先であいうえお順ソート
  function isKatakana(str) {
    return /^[\u30A0-\u30FF]+$/.test(str);
  }

  const sortedGemstones = [...gemstones].sort((a, b) => {
    const aKatakana = isKatakana(a.name_ja);
    const bKatakana = isKatakana(b.name_ja);

    if (aKatakana && !bKatakana) return -1; // aがカタカナ、bが漢字 → a先
    if (!aKatakana && bKatakana) return 1;  // aが漢字、bがカタカナ → b先

    // 両方カタカナ or 両方漢字の場合はあいうえお順
    return a.name_ja.localeCompare(b.name_ja, 'ja');
  });

  const sel = document.getElementById("stone");
  sel.innerHTML = ""; // 既存のoptionをクリア
  sortedGemstones.forEach(s=>{
    const opt = document.createElement("option");
    opt.value = s.id;
    opt.textContent = s.name_ja;
    sel.appendChild(opt);
  });
}

async function loadCuts(){
  const res = await fetch('./data/cuts.json').then(r=>r.json());
  cuts = res.cuts;
  const sel = document.getElementById("cut");
  cuts.forEach(c=>{
    const opt = document.createElement("option");
    opt.value = c.id;
    opt.textContent = c.name_ja;
    sel.appendChild(opt);
  });
  sel.addEventListener("change", updateDimensionFields);
  updateDimensionFields();
}

async function loadModels(){
  const res = await fetch('./data/models.json').then(r=>r.json());
  models = {};
  res.models.forEach(m=>models[m.id]=m);
}

// ----------------- calibrations.json 読み込み -----------------
async function loadCalibrations(){
  try{
    const res = await fetch('./data/calibrations.json');
    const data = await res.json();
    calibrations = data.calibrations || [];
  }catch(e){
    calibrations = [];
    console.warn("calibrations.json 読み込み失敗:", e);
  }
}

// ----------------- 寸法フィールド生成 -----------------
function updateDimensionFields(){
  const cutId = document.getElementById("cut").value;
  const cutObj = cuts.find(c=>c.id===cutId);
  if(!cutObj) return;
  const fields = cutObj.measurement_fields;

  const area = document.getElementById("dimensions");
  area.innerHTML="";

  fields.forEach(f=>{
    const label = {
      d: "直径(mm)",
      D: "厚み/全高(mm)",
      L: "縦(mm)",
      W: "横(mm)",
      a: "辺長(mm)",
      r: "最大半径(mm)",
      h: "高さ(mm)",
      h_half: "片側高さ(mm)",
      A: "底面積(mm²)",
      split_ratio: "上部割合(0.4〜0.7推奨)"
    }[f] || f;

    const row = document.createElement("div");
    row.className="row";
    row.innerHTML = `<label>${label}</label>
      <input id="dim_${f}" type="number" step="0.01" value="${f==='split_ratio'?0.6:''}">`;
    area.appendChild(row);
  });
}

// ----------------- 登録処理 -----------------
document.getElementById("addBtn").addEventListener("click", async ()=>{
  try{
    const stoneId = document.getElementById("stone").value;
    const cutId = document.getElementById("cut").value;
    const cutObj = cuts.find(c=>c.id===cutId);
    if(!stoneId || !cutId){ alert("石とカットを選択してください"); return; }

    const entry = {stone: stoneId, cut: cutId, date: new Date().toISOString()};

    // 寸法フィールド
    const args=[];
    cutObj.measurement_fields.forEach(f=>{
      const val=parseFloat(document.getElementById("dim_"+f).value) || 0;
      entry[f]=val;
      args.push(val);
    });

    // 計算重量
    const stoneObj = gemstones.find(s=>s.id===stoneId);
    const model = models[cutObj.model];
    if(!model){ alert("モデルが未定義です"); return; }
    
    // 修正版: evalを一旦関数化
    const func = eval(model.formula_js);
    let V = func(...args);
    V *= cutObj.correction_factor;
    const calculated_g = stoneObj.sg_std * V / 1000;
    entry.calculated_g = parseFloat(calculated_g.toFixed(3));
    console.log("計算重量:", calculated_g);

    // 実測重量
    const measured_g = parseFloat(document.getElementById("measured_g").value) || 0;
    if(!measured_g){ alert("実測重量を入力してください"); return; }
    entry.measured_g = measured_g;

    // 補正係数
    entry.correction_factor = parseFloat((measured_g / calculated_g).toFixed(3));

    calibrations.push(entry);
    displayCalibrations();
    await saveToGitHub();
    alert("登録しました！");
  } catch(e){
    console.error("登録処理エラー:", e);
    alert("登録処理中にエラーが発生しました。コンソールを確認してください。");
  }
});

// ----------------- GitHub 保存 -----------------
async function saveToGitHub() {
  const owner = "sgc-gold";
  const repo = "sgc";
  const path = "data/calibrations.json";
  const ghToken = localStorage.getItem("ghToken");
  if (!ghToken) throw new Error("GitHubトークンが設定されていません。");

  // --- 現在のcalibrations.jsonを取得 ---
  let sha = null;
  let existingData = { calibrations: [] };

  try {
    const resGet = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${path}`, {
      headers: { Authorization: "token " + ghToken }
    });

    if (resGet.ok) {
      const data = await resGet.json();
      sha = data.sha;
      existingData = JSON.parse(atob(data.content));
    } else if (resGet.status === 404) {
      console.log("calibrations.json は存在しません。新規作成します。");
    } else {
      throw new Error("GitHub GET 失敗: " + resGet.status);
    }
  } catch (e) {
    console.warn("既存データの取得に失敗しました:", e);
  }

  // --- フロント側の補正データを追加 ---
  if (!calibrations.length) {
    throw new Error("登録データが存在しません。");
  }
  const latest = calibrations[calibrations.length - 1]; // 直近の登録データ

  // 同一stone & cutがある場合は上書き（重複防止）
  existingData.calibrations = existingData.calibrations.filter(c =>
    !(c.stone === latest.stone && c.cut === latest.cut)
  );
  existingData.calibrations.push(latest);

  const content = btoa(unescape(encodeURIComponent(JSON.stringify(existingData, null, 2))));

  // --- PUTでGitHubに保存 ---
  const resPut = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${path}`, {
    method: "PUT",
    headers: {
      Authorization: "token " + ghToken,
      "Content-Type": "application/json"
    },
    body: JSON.stringify({
      message: `Add calibration (${latest.stone}-${latest.cut})`,
      content,
      sha: sha || undefined
    })
  });

  if (!resPut.ok) {
    const errText = await resPut.text();
    console.error("PUT失敗:", errText);
    throw new Error("GitHub保存に失敗しました。");
  }

  alert("calibrations.json に保存しました。");
}

// ----------------- 一覧表示 -----------------
function displayCalibrations(){
  const tbody = document.querySelector("#calibTable tbody");
  tbody.innerHTML="";

  calibrations.forEach(c=>{
    const stoneName = gemstones.find(s=>s.id===c.stone)?.name_ja || c.stone;
    const cutName = cuts.find(cu=>cu.id===c.cut)?.name_ja || c.cut;
    const dims = cuts.find(cu=>cu.id===c.cut).measurement_fields.map(f=>`${f}:${c[f]||''}`).join(", ");

    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td>${stoneName}</td>
      <td>${cutName}</td>
      <td>${dims}</td>
      <td>${c.calculated_g}</td>
      <td>${c.measured_g}</td>
      <td>${c.correction_factor}</td>
      <td>${new Date(c.date).toLocaleString()}</td>
    `;
    tbody.appendChild(tr);
  });
}
</script>
</body>
</html>